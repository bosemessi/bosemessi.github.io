---
title: "3d -> 2d perspective transforms in football viz"
layout: post
---

Let me begin by saying that this post isn't gonna teach you anything about football analytics and tactics and data science. In any case you probably are way more knowledgable in all of that than me. This is a post dedicated to creating 3d plots in matplotlib without using their native 3d utilities (which I don't like, at all). Instead, I will be using a wonderful library built on top of matplotlib but with clever modifications to handle depth (otherwise known as zorder for those of you are used to matplotlib and mplsoccer) near perfectly. The author of the library is Nicolas P. Rougier, and the library itself can be found [here](https://github.com/rougier/matplotlib-3d). Extremely simple installation instructions - pip install git+https://github.com/rougier/matplotlib-3d, and you would do yourself a favor by first reading this [blog post](https://matplotlib.org/matplotblog/posts/custom-3d-engine/) and the [documentations](https://github.com/rougier/matplotlib-3d/blob/master/doc/README.md).

So, what's our objective here ? First I am going to show you how to create a 3d pitch by using the library. Secondly, I am going to use some fake data to show how you can plot events like passes and shots in 3d. In particular, I will display a long ball in 3d that takes a parabolic trajectory, a shot from distance that nestles into the top corner also following a parabolic trajectory, and a shot from very close distance that rockets into the roof of the goal, straight up. So, basically I will show you how to plot parabolas and straight lines on top of the 3d pitch. Let's jump right in.

Let's start with some imports. If you unhide the following you will see the libraries we are importing...essentially matplotlib, numpy, mpl3d by Nicolas Rougier and optionally mplsoccer by Andy Rowlinson. Oh, and ipywidgets for some interactivity (this is assuming you are using jupyter notebooks).


<details>
    <summary>Click to expand!</summary>

import numpy as np
import matplotlib.pyplot as plt
from mpl3d import glm
from mpl3d.mesh import Mesh
from mpl3d.camera import Camera
from matplotlib.collections import PolyCollection, LineCollection
import ipywidgets as widgets
from ipywidgets import interactive, fixed
</details>

## Task 1 : Draw a pitch

To draw a pitch, you need the dimensions and the coordinates of the various lines and circles etc. We are going to draw pitch with UEFA dimensions (105*68) but you can choose others too if you prefer. If you don't know the coordinates already, its easy to use to mplsoccer to know the dimensions of the pitch of your preference, as follows : 

<details>
    <summary>Click to expand!</summary>

```tsql
pitch = Pitch(pitch_type = 'uefa')
pitch.dim
```
</details>

Now, if you have read the documentation, you will have noticed that to plot stuff, we need to provide some vertices and faces to create polygons and show them on an axis. So for example, take the uefa pitch outline....it has length 105 and width 68. So the vertices are [0,0,0], [105,0,0], [105,68,0] and [0,68,0] - the four corners of the pitch. The height of the pitch is zero as shown by the third coordinate in the triplets of numbers. The face is the pitch itself, delineated by the 4 vertices mentioned in order [[0,1,2,3]]. This is how you specify each object - by their vertices coordinates and by faces. The following does it for every single bits on the pitch : 

<details>
    <summary>Click to expand!</summary>

```tsql
pitch_outline = np.array(
    [
        [0.0, 0.0, 0.0],
        [105.0, 0.0, 0.0],
        [105.0, 68.0, 0.0],
        [0.0, 68.0, 0.0],
    ]
)
f_pitch_outline = [[0, 1, 2, 3]]

right_penalty_box = np.array(
    [
        [88.5, 13.84, 0.0],
        [105.0, 13.84, 0.0],
        [105.0, 54.16, 0.0],
        [88.5, 54.16, 0.0],
    ]
)

f_right_penalty_box = [[0, 1, 2, 3]]

left_penalty_box = np.array(
    [
        [0.5, 13.84, 0.0],
        [16.5, 13.84, 0.0],
        [16.5, 54.16, 0.0],
        [0.0, 54.16, 0.0],
    ]
)

f_left_penalty_box = [[0, 1, 2, 3]]

right_6yd_box = np.array(
    [
        [99.5, 24.84, 0.0],
        [105.0, 24.84, 0.0],
        [105.0, 43.16, 0.0],
        [99.5, 43.16, 0.0],
    ]
)

f_right_6yd_box = [[0, 1, 2, 3]]

left_6yd_box = np.array(
    [
        [0, 24.84, 0.0],
        [5.5, 24.84, 0.0],
        [5.5, 43.16, 0.0],
        [0, 43.16, 0.0],
    ]
)

f_left_6yd_box = [[0, 1, 2, 3]]

centerline = np.array([[52.5, 0.0, 0.0], [52.5, 68, 0.0]])
f_centerline = [[0, 1]]

two_pi_angles = np.linspace(0, 2.0 * np.pi, 100)
centercircle = np.array(
    [52.5 + 9.15 * np.cos(two_pi_angles), 34 + 9.15 * np.sin(two_pi_angles), np.zeros(100)]
).transpose()
f_centercircle = [[i for i in range(len(centercircle))]]

def int_angles(radius, h, k, line_y):
    x1 = h + np.sqrt(radius**2 - (line_y - k) ** 2)
    x2 = h - np.sqrt(radius**2 - (line_y - k) ** 2)
    theta1 = np.arccos((x1 - h) / radius)
    theta2 = np.pi - theta1
    return theta1, theta2


theta1, theta2 = int_angles(9.15, 34, 94, 88.5)
lin1 = np.linspace(np.pi / 2 + theta1, np.pi / 2 + theta2, 200)
lin2 = np.linspace(-np.pi/2+theta1,-np.pi/2+theta2,200)
right_arc = np.array(
    [94 + 9.15 * np.cos(lin1), 34 + 9.15 * np.sin(lin1), np.zeros(200)]
).transpose()

f_right_arc = [[i for i in range(len(right_arc))]]

left_arc = np.array(
    [11 + 9.15 * np.cos(lin2), 34 + 9.15 * np.sin(lin2), np.zeros(200)]
).transpose()

f_left_arc = [[i for i in range(len(left_arc))]]


right_goal = np.array(
    [
        [105, 30.34, 0.0],
        [105, 30.34, 2.4],
        [105, 37.66, 2.4],
        [105, 37.66, 0],
        [107, 30.34, 0.0],
        [107, 30.34, 2.4],
        [107, 37.66, 2.4],
        [107, 37.66, 0],
    ]
)

f_right_goal = [[4, 5, 6, 7], [0, 1, 5, 4], [2, 6, 7, 3], [1, 2, 6, 5]]

left_goal = np.array(
    [
        [0, 30.34, 0.0],
        [0, 30.34, 2.4],
        [0, 37.66, 2.4],
        [0, 37.66, 0],
        [-2, 30.34, 0.0],
        [-2, 30.34, 2.4],
        [-2, 37.66, 2.4],
        [-2, 37.66, 0],
    ]
)

f_left_goal = [[4, 5, 6, 7], [0, 1, 5, 4], [2, 6, 7, 3], [1, 2, 6, 5]]

```
</details>

Once the pitch coordinates are set, we move on to the actual plotting. We will first define a function called camera transform that will take two parameters (think of them as viewing angles in 3d) and return a perspective transformed image. Then we will define a viewer function where we will define our figure and axis, then call the camera transform on each set of vertices and faces and display them. The two functions are defined below.  

<details>
    <summary>Click to expand!</summary>

```tsql

def camera_transform(params, vertices, faces, indx, ax, fc, ec):
    vertices[:, 0] = (vertices[:, 0] - 52.5) / 52.5
    vertices[:, 1] = (vertices[:, 1] - 34) / 52.5
    vertices[:, 2] = (vertices[:, 2] - 2.5 / 2) / 52.5
    camera = Camera("perspective", params[0], params[1], scale=0.8)
    vertices = glm.transform(vertices, camera.transform)

    faces = np.array([vertices[face] for face in faces])
    index = np.argsort(-np.mean(faces[..., 2].squeeze(), axis=-1))
    vertices = faces[index][..., :2]

    collection = PolyCollection(vertices, facecolor=fc, edgecolor=ec)
    ax.add_collection(collection)

#     ax.set_ylim(-0.4, 0.3)
#     ax.set_xlim(-1.5, 1.5)
    return ax

def viewer(theta, phi):
    fig = plt.figure(figsize=(12, 12))
    ax = fig.add_axes([0, 0, 1, 1], xlim=[-1, 1], ylim=[-1, 1], aspect=1)
    ax.axis("off")
    ax.set_title("Plotting 3d Pitch", color="w", fontsize=20)
    fig.set_facecolor("k")
    ax.set_facecolor("k")

    camera_transform(
        params=[theta, phi],
        vertices=pitch_outline.copy(),
        faces=f_pitch_outline.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=right_penalty_box.copy(),
        faces=f_right_penalty_box.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=left_penalty_box.copy(),
        faces=f_left_penalty_box.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=right_6yd_box.copy(),
        faces=f_right_6yd_box.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=left_6yd_box.copy(),
        faces=f_left_6yd_box.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=centerline.copy(),
        faces=f_centerline.copy(),
        indx=1,
        ax=ax,
        fc="grey",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=centercircle.copy(),
        faces=f_centercircle.copy(),
        indx=1,
        ax=ax,
        fc="none",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=right_arc.copy(),
        faces=f_right_arc.copy(),
        indx=1,
        ax=ax,
        fc="none",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=left_arc.copy(),
        faces=f_left_arc.copy(),
        indx=1,
        ax=ax,
        fc="none",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=right_goal.copy(),
        faces=f_right_goal.copy(),
        indx=1,
        ax=ax,
        fc="none",
        ec="w",
    )
    camera_transform(
        params=[theta, phi],
        vertices=left_goal.copy(),
        faces=f_left_goal.copy(),
        indx=1,
        ax=ax,
        fc="none",
        ec="w",
    )


plt.show()

```
</details>

If you set $\theta = 80 $ and $\phi = 90$ and call the viewer function,  you will get the following. 

![Image](https://bosemessi.github.io/images/pitch1.png)

If you set $\theta = 80 $ and $\phi = 40$, you will get the following.

![Image](https://bosemessi.github.io/images/pitch2.png)

Cool, yeah ?! It definitely looks slick to me. I will leave to uncomment the two axis limit setting lines and play around with the numbers until you find something that looks good. Oh, and if you are tired of manually inputting the values, don't worry - ipywidgets got you covered. Just do the following : 

<details>
    <summary>Click to expand!</summary>

```tsql
phi_vals = widgets.FloatSlider(
    value=10,
    min=0,
    max=360.0,
    step=10,
    description="Phi:",
    disabled=False,
    continuous_update=False,
    orientation="horizontal",
    readout=True,
    readout_format=".1f",
)

theta_vals = widgets.FloatSlider(
    value=80,
    min=0,
    max=180.0,
    step=10,
    description="Theta:",
    disabled=False,
    continuous_update=False,
    orientation="horizontal",
    readout=True,
    readout_format=".1f",
)

interactive(viewer, theta=theta_vals, phi=phi_vals)

```
</details>

Now you can drag the sliders and change the orientation of the 3d pitch. My recommendations - keep $\theta$ fixed between 60 and 90, and just change $\phi$.


## Task 2 : Draw a straight 3d line  - a straight shot into the roof of the net. 

Coming soon.....
